package covid.arrow

import arrow.optics.Lens
import arrow.optics.PLens
import arrow.optics.optics

// Optics = abstractions to update immutable data structures in an elegant way

@optics
data class User(val address: Address, val other: String = "foo") {
    companion object
}

@optics
data class Address(val street: Street, val other: String = "bar") {
    companion object
}

@optics
data class Street(val number: Int, val other: Int = 1337) {
    companion object
}

val user = User(Address(Street(42)))

fun main() {
    `sample copy`()
//    `sample Lens`()
}

fun `sample copy`() {
    val userOldSchool = // old school way of doing it, pretty cumbersome
        user.copy(address = user.address.copy(street = user.address.street.copy(number = user.address.street.number + 1)))

    // just use the lenses created by arrow through @optics
    val userNewSchool = User.address.street.number.modify(user) { it + 1 }

    println("old lens: $user")
    val user2 = user.modify({ address.street.number }) { it + 1 }
    println("new lens: $user2")


    println("old: $userOldSchool")
    println("new: $userNewSchool")
}

fun <T> User.modify(lens: User.Companion.() -> PLens<User, User, T, T>, modify: (T) -> T): User =
    lens.invoke(User.Companion).modify(this) { modify(it) }


// OLD: Band.members.guitarMember.instrument.guitar.modify(band) { "new string" }
// ... feels like: SomeUtil.bend(knee, 42)
//fun <T> Band.modify(lens: Band.Companion.() -> PLens<Band, Band, T, T>, modify: (T) -> T) =
//    lens.invoke(Band.Companion).modify(this) { modify(it) }
// NEW: band.modify({ members.guitarMember.instrument.guitar }) { "new string }
// ... now like: knee.bend(42) // as in subject-predicate-object

fun `sample Lens - not necesary as generated by optics, yay`() {
//    val streetNumberLens: Lens<User, Int> = Lens(
//        get = { it.address.street.number },
//        set = { u, v -> u.copy(address = u.address.copy(street = u.address.street.copy(number = v))) },
//    )
    val addressLens: Lens<User, Address> = Lens(
        get = { it.address },
        set = { u, v -> u.copy(address = v) }
    )
    val streetLens: Lens<Address, Street> = Lens(
        get = { it.street },
        set = { u, v -> u.copy(street = v) }
    )
    val streetNumberLens: Lens<Street, Int> = Lens(
        get = { it.number },
        set = { u, v -> u.copy(number = v) }
    )
    val userStreetNumberLens: Lens<User, Int> = addressLens compose streetLens compose streetNumberLens

    println("Street number: ${userStreetNumberLens.get(user)}")
    val userLensed = userStreetNumberLens.set(user, 21)
    println("Street number lensed: ${userStreetNumberLens.get(userLensed)}")
    val liftUp: (User) -> User = userStreetNumberLens.lift { it + 10 }
    println("lifted: ${liftUp(user)}")
}
